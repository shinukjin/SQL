select * from emp;

--오라클 컨스트레인트스 : Oracle Constraints
--오라클은 종속된 테이블의 삭제를 방지하고, 테이블에 유효하지 않은 데이터가 입력되는 것을 
--방지하기 위해서 CONSTRAINTS를 사용한다.
--DMP 문장에서 일어나는 일
-- 오라클 트랜잭션이 발생할 때 일어나는 일

CREATE TABLE CONST_TEST( 
    CONST_1 NUMBER(4) PRIMARY KEY -- 컬럼명 데이터타입 제약조건
    ,CONST_2 VARCHAR2(20) NOT NULL
    ,CONST_3 VARCHAR2(10) UNIQUE
);

--USER_CONSTRAINTS : 제약 조건을 보기위한 데이터 딕셔너리 테이블
--P: PRIMARY KEY
--F: FOREIGN KEY
--C : CHECK OR NOT NULL
--U : UNIQUE


SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
FROM USER_CONSTRAINTS
WHERE TABLE_NAME='CONST_TEST';

CREATE TABLE CONST_TEST( 
    CONST_1 NUMBER(4) PRIMARY KEY -- NOT NULL + UNIQUE
    ,CONST_2 VARCHAR2(20) NOT NULL
    ,CONST_3 VARCHAR2(10) UNIQUE
);

INSERT INTO CONST_TEST VALUES(1111, '1111', '1111');
INSERT INTO CONST_TEST VALUES(1111, '2222', '2222');
INSERT INTO CONST_TEST VALUES(NULL, '2222', '2222');
INSERT INTO CONST_TEST VALUES(1112, NULL, '2222');
INSERT INTO CONST_TEST VALUES(1112, '1112', '2222');
INSERT INTO CONST_TEST VALUES(1112, '1112', '1111');
COMMIT;
SELECT * FROM CONST_TEST;

CREATE TABLE CONST_TEST_1(
     CONST_1 NUMBER(4) CONSTRAINT CONST_TEST_1_CONT_1_PK PRIMARY KEY
    ,CONST_2 VARCHAR2(20) CONSTRAINT CONST_TEST_1_CONT_2_NN NOT NULL
    ,CONST_3 VARCHAR2(10) CONSTRAINT CONST_TEST_1_CONT_3_UK UNIQUE
);

SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'CONST_TEST_1' ;

CREATE TABLE CONST_TEST_2(
     CONST_1 NUMBER(4) 
    ,CONST_2 VARCHAR2(20) CONSTRAINT CONST_TEST_2_CONT_2_NN NOT NULL
    ,CONST_2 VARCHAR2(10)
    ,CONSTRAINT CONST_TEST_2_CONT_1_PK PRIMARY KEY(CONST_1)
    ,CONSTRAINT CONST_TEST_2_CONT_3_UK UNIQUE(CONST_3)
);
COMMIT;

--USER_CONS-COULUMNS : 제약조건이름과 연관된 컬럼을 볼 수 있는 딕셔너리
SELECT * FROM USER_CONS_COLUMNS
WHERE TABLE_NAME = 'EMP';

SELECT * FROM USER_CONS_COLUMNS
WHERE TABLE_NAME = 'DEPT';

DESC DEPT;
SELECT * FROM TAB;

CREATE TABLE EMP06(
     EMPNO NUMBER(4) CONSTRAINT EMP06_EMPNO_PK PRIMARY KEY
    ,ENAME VARCHAR2(1) CONSTRAINT EMP06_ENAME_NN NOT NULL
    ,JOB VARCHAR2(9) CONSTRAINT EMP06_JOV_UK UNIQUE
    ,DEPTNO NUMBER(2) CONSTRAINT EMP06_DEPTNO_FK REFERENCES DEPT(DEPTNO)
    );

SELECT * FROM EMP06;

--CHECK :저장 가능한 데이터 값의 범위나 조건을 지정하여 설정한 값만을 허용한다.
--DEFAULT : 정해진 값 입력
CREATE TABLE CON_TEST_1(
     CON_1 NUMBER(4) PRIMARY KEY
    ,CON_2 VARCHAR2(2) NOT NULL
    ,CON_3 VARCHAR2(1) CHECK(GENDER IN('M', 'F'))
);

-- CHECK 제약 위반 조건 C_3 > 0 보다 커야함 , -200넣었을 경우
CREATE TABLE CON_TEST_2(
     C_1 NUMBER(4) 
    ,C_2 VARCHAR2(20) 
    ,C_3 NUMBER(7, 2) CONSTRAINT CON_TEST_2_C_3 CHECK (C_3> 0)
);

INSERT INTO CON_TEST_2 VALUES(111, '111', -200);


CREATE TABLE CON_TEST_3(
    C_GENDER VARCHAR2(1) CONSTRAINT CON_TEST_3_C_GENDER_CHECK CHECK(C_GENDER IN('M','F'))
);
-- 체크제약조건 위반
INSERT INTO CON_TEST_3 VALUES('R');

CREATE TABLE CON_TEST_4(
    C_DELYN VARCHAR2(1) CONSTRAINT CON_TEST_4_C_DELYN_CHECK CHECK(C_DELYN IN('Y', 'N'))
);

SELECT * FROM CON_TEST_4;
SELECT * FROM USER_CONS_COLUMNS
WHERE TABLE_NAME = 'CON_TEST_4';

CREATE TABLE CON_TEST_6(
     C_1 NUMBER(4) PRIMARY KEY
    ,C_2 NUMBER(7,2) DEFAULT 1000
);

INSERT INTO CON_TEST_6(C_1) VALUES(111);
SELECT * FROM CON_TEST_6;


CREATE TABLE T_EMP03(
     T_EMPNO NUMBER(4)
    ,T_ENAME VARCHAR2(10) CONSTRAINT EMP03_ENAME_NN NOT NULL
    ,T_JOB VARCHAR2(9)
    ,T_DEPTNO NUMBER(2)
    ,T_GENDER VARCHAR2(1) CONSTRAINT CON_TEST_3_T_GENDER_CHEKCK CHECK (T_GENDER IN ('M', 'F'))
    ,T_DELYN VARCHAR2(1) CONSTRAINT CON_TEST_4_T_DELYN_CHECK CHECK (T_DELYN IN ('Y', 'N'))
    ,T_INSERTDATE DATE DEFAULT SYSDATE
    ,T_UPDATEDATE DATE DEFAULT SYSDATE
    ,CONSTRAINT T_EMP03_T_EMPNO_PK PRIMARY KEY(T_EMPNO)
    ,CONSTRAINT T_EMP03_T_JOB_UK UNIQUE(T_JOB)
    ,CONSTRAINT T_EMP03_T_DEPTNO_FK FOREIGN KEY(T_DEPTNO) REFERENCES DEPT(DEPTNO) 
    -- 테이블명, 데이터타입 CONSTRAINT 테이블명 컬럼명 제약조건순으로 쓰는것같음.

);

-- 우리는 만들떄 이렇게 만들것.
CREATE TABLE T_EMP03_1(
     T_EMPNO NUMBER(4) PRIMARY KEY
    ,T_ENAME VARCHAR2(10) NOT NULL
    ,T_JOB VARCHAR2(9) UNIQUE
    ,T_DEPTNO NUMBER(2)
    ,T_GENDER VARCHAR2(1) --입력할 떄 코드값으로 , 보여줄 떄 치환하기
    ,T_DELYN VARCHAR2(1) --쿼리문에서 YN
    ,T_INSERTDATE DATE --쿼리문에서 SYSDATE
    ,T_UPDATEDATE DATE --쿼리문에서 SYSDATE

    -- 테이블명, 데이터타입 CONSTRAINT 테이블명 컬럼명 제약조건순으로 쓰는것같음.
);

--#########################################################################
--DUMP() 함수
--DUMP(expression, [, return_formay], [, strat_position][, length])
--DUMP 함수는 데이터타입, 바이트 길이 및 expression이 내부 표현정보를  VARCHARE2형식으로 반환하는 함수 이다.

--값       내용
--8       8진법
--10      10진법
--16      16진법
--17      단일문자
--1008    문자셋과 8진법
--1010    문자셋과 10진법
--1016    문자셋과 16진법
--1017    문자셋과 단일문자

SELECT DUMP('DUMP') AS DUMP_RESULT FROM DUAL;
--TYP=96 : CHAR 또눈 NCHAR 타입
--LEN=4 : 'DUMP'의 문자길이
--68, 85, 77, 80 : DUMP를 10진수로 표현한 결과

SELECT DUMP('DUMP', 8) AS DUMP_RESULT FROM DUAL; -- 8진수로
SELECT DUMP('DUMP', 10) AS DUMP_RESULT FROM DUAL; --10진수로
SELECT DUMP('DUMP', 16) AS DUMP_RESULT FROM DUAL; -- 16진수로
SELECT DUMP('DUMP', 17) AS DUMP_RESULT FROM DUAL; -- 단일문자로

SELECT DUMP('DUMP', 1008) AS DUMP_RESULT FROM DUAL;
SELECT DUMP('DUMP', 1010) AS DUMP_RESULT FROM DUAL;
SELECT DUMP('DUMP', 1016) AS DUMP_RESULT FROM DUAL;
SELECT DUMP('DUMP', 1017) AS DUMP_RESULT FROM DUAL;

--Unicode Database [ ASCII-Based platforms ]

--UTF8 : Unicode Version ? 2.1 ~3.0
--지원 RDBMS 8.0 ~ 9I
--Unicode Encoding ? UTF8
--8i보다 하위버전의 Client 존재 시 UTF8 사용 필수

--AL32UTF8 : Unicode Version ? 3.0 ~ 3.1 Version
--지원 RDBMS 9i 이후
--Unicode Encoding ? UTF8
--9i/10G 에서 UTF8 Default CharacterSet
--8i보다 하위 버전의 Client 존재시 AL32UTF8 사용시 문제 발생 가능

-- 빈 공간(32)를 찾기위해서 DUMP를 많이 사용한다.
--SELECT DUMP(' ') FROM DUAL;
--SELECT DUMP(' TEST') FROM DUAL;

SELECT 'Oracle mania', UPPER('Oracle mania'), LOWER('Oracle mania'), INITCAP('Oracle mania')
FROM DUAL;
SELECT 
     A.EMPNO EMPNO
    ,A.ENAME ENAME
    ,A.JOB   JOB
FROM EMP A
WHERE UPPER(A.ENAME) = UPPER('miller');
--WHERE LOWER(A.ENAME) = LOWER('miller');


--LENGTH : 문자 길이 : 한글 1BYTE : 문자갯수
--LENGTHB : 문자 길이 : 한글 2BYTE
SELECT LENGTH('Oracle mania'), LENGTH('오라클매니아') FROM DUAL;
SELECT LENGTHB('Oracle mania'), LENGTHB('오라클매니아') FROM DUAL;

--GREATEST
SELECT GREATEST(11, 105, 50, -22) FROM DUAL; -- 인자중 최대값
--LEAS
SELECT LEAST(11, 105, 50, -22) FROM DUAL;

--UDI는 현재 사용자의 유일한 ID 번호를 반환하고
--USER는 현재 오라클 사용자를 VSRCHAR2형식으로 반환한다.
SELECT USER, UID FROM DUAL;

--USERENV 함수는 현재 세선의 환경정보를 반환한다.
--ENTRYID : 사용 가능한 Auditing entry Identifier 를 반환
--LABEL : 현재 세션의 Label을 반환
--LANGUAGE : 현재 세션에서 사용중인 언어와 테리토리 값을 반환
--SESSIONID : Auditing(감사) Session ID를 반환
--TERMINAL : 현재 세션 터미널의 OS ID를 반환
SELECT USERENV('LANGUAGE') "Language" FROM DUAL;

--VSIZE 해당 문자의 BYTE 수를 반환, 해당 문자가 NULL이면 NULL값 반환
SELECT VSIZE('Database') FROM DUAL;

--LPAD, RPAD
SELECT LPAD('DataBase', 20, ' ') FROM DUAL;
SELECT LENGTH(LPAD('DataBase', 20, ' ')) FROM DUAL;
SELECT LPAD('KOREA', 8, '*') FROM DUAL;
SELECT LENGTH(LPAD('KOREA', 8, '*')) FROM DUAL;
SELECT RPAD('DataBase', 20, '$') FROM DUAL;
SELECT LENGTH(RPAD('DataBase', 20, '$')) FROM DUAL;
SELECT RPAD('KOREA', 8, '*') FROM DUAL;
SELECT LENGTH(RPAD('KOREA', 8, '*')) FROM DUAL;

SELECT LPAD(NVL(NULL, 0), -4, '0') + 1 FROM DUAL; 

SELECT NULL FROM DUAL;
SELECT NVL(NULL, 0) FROM DUAL;
SELECT NVL(NULL, 0) + 1 FROM DUAL;
SELECT LPAD('1', 4, '0') FROM DUAL;
SELECT LPAD((NVL(NULL, 0) + 1), 4, '0') FROM DUAL;


--TRIM
SELECT TRIM('a' FROM 'aaaaDataBase programingaaa')FROM DUAL;
SELECT TRIM(LEADING 'a' FROM 'aaaaDataBase programingaaa') FROM DUAL;
SELECT TRIM(TRAILING 'a' FROM 'aaaaDataBase programingaaa') FROM DUAL;
SELECT TRIM(BOTH 'a' FROM 'aaaaDataBase programingaaa') FROM DUAL;
SELECT TRIM('  aaaaDataBase programingaaa  ')FROM DUAL;
SELECT DUMP('  aaaaDataBase programingaaa  ') FROM DUAL;
SELECT TRIM(BOTH FROM '  ABCD  ') BOTH1, LENGTH(TRIM(BOTH FROM ' ABCD ' )) BOTH1 FROM DUAL;


--SUBSTR
SELECT HIREDATE FROM EMP WHERE SUBSTR(HIREDATE,1, 1, 2) = '81';
SELECT SUBSTR(HIREDATE, 1, 2) FROM EMP;
SELECT TO_CHAR(GIREDATE, 'YYYYMMDD') FROM EMP;

SELECT SUBSTR(TO_CHAR(TO_DATE('1981-02-01'), 'YYYYMMDD'), 1, 6) FROM DUAL;

SELECT COUNT(EMPNO) FROM EMP
WHERE SUBSTR(TO_CHAR(HIREDATE, 'YYYYMMDD'), 1, 6) = SUBSTR(TO_CHAR(TO_DATE('1981-02-01'), 'YYYYMMDD'), 1, 6);

SELECT SUBSTR('ABCDEFGHI', -4) FROM DUAL;
SELECT SUBSTR('20210817', -4, 2) FROM DUAL;
SELECT SUBSTR('20210817' , -2) FROM DUAL;

--CONCATE
SELECT CONCAT('Oracle', '매니아') FROM DUAL;

--INSTR
SELECT INSTR('DataBase' , 'a') FROM DUAL;
SELECT INSTR('DataBase' , 'a', 3, 1) FROM DUAL;
SELECT INSTR('DataBase' , 'a', 3, 2) FROM DUAL;


--ABS(), ROUND(), FLOOR(), MOD()
SELECT ABS(-15) FROM DUAL;
SELECT 98.7597, ROUND(98.7597), ROUND(98.7597, 2), ROUND(98.7597, -1) FROM DUAL;
SELECT 98.7597, TRUNC(98.7597), TRUNC(98.7597, 2), TRUNC(98.7597, -1) FROM DUAL;
SELECT FLOOR(34.5678) FROM DUAL;
SELECT MOD(3,2), MOD(34,2), MOD(34,5), MOD(34,7) FROM DUAL;
SELECT TRUNC(150/60)||'분'||MOD(150,60)||'초' FROM DUAL;

SELECT A.EMPNO
      ,MOD(A.EMPNO, 2) 짝수
      ,A.ENAME
      ,A.JOB
FROM EMP A
WHERE
MOD(A.EMPNO, 2) =0;


--NVL(), REPLACE
SELECT NVL(NULL, 0)
      ,NVL('', 'AA')
      ,NVL(NULL, 'BB')
FROM DUAL;

-- 날짜 함수
SELECT SYSDATE FROM DUAL;
SELECT STSTIMSTAMP FROM DUAL;

SELECT SYSDATE -1 어제 FROM DUAL;
SELECT SYSDATE 오늘 FROM DUAL;
SELECT SYSDATE +1 FROM DUAL;

SELECT ROUND(MONTHS_BETWEEN(SYSDATE, '1998-10-02')) MONTHS FROM DUAL; --275
SELECT ROUND(MONTHS_BETWEEN(SYSDATE, '1988-12-15')) MONTHS FROM DUAL; --392
SELECT ROUND(MONTHS_BETWEEN(SYSDATE,'1988-12-15')) 
        - ROUND(MONTHS_BETWEEN(SYSDATE,'1998-10-02'))
MONTHS FROM  DUAL;

SELECT ROUND(MONTHS-BETWEEN(SYSDATE, '1963-07-25')) MONTHS FROM DUAL;
SELECT ROUND(MONTHS_BETWEEN(SYSDATE, '1963-07-25'))
            - ROUND(MONTHS_BETWEEN(SYSDATE, '1998-10-02'))
MONTHS FROM DUAL;

SELECT 
        SYSDATE
        ,A.HIREDATE
        ,ROUND(MONTHS_BETWEEN(SYSDATE, A.HIREDATE)) AA
        ,TRUNC(MONTHS_BETWEEN(SYSDATE, A.HIREDATE)) BB
FROM EMP A
WHERE A.DEPTNO = 10;

SELECT ADD_MONTHS(SYSDATE, 3) FROM DUAL;

--요일
--1:일 2:월 3:화 4:수 5:목 6:금 7:토

SELECT SYSDATE, NEXT_DAY(SYSDATE, '수요일') FROM DUAL;
SELECT SYSDATE, NEXT_DAY(SYSDATE, '수') FROM DUAL;
SELECT TO_CHAR(TO_DATE('20210817'), 'd') FROM DUAL;
SELECT TO_CHAR(TO_DATE('20210817'), 'dy') FROM DUAL;
SELECT TO_CHAR(TO_DATE('20210817'), 'day') FROM DUAL;

SELECT TO_CHAR(SYSDATE,'d') FROM DUAL;
SELECT TO_CHAR(SYSDATE,'dy') FROM DUAL;
SELECT TO_CHAR(SYSDATE,'day') FROM DUAL;

SELECT NEXT_DAY(SYSDATE, 6) FROM DUAL;
SELECT LAST_DAY(STSDATE) FROM DUAL;

SELECT 10 + 20 FROM DUAL;
SELECT '10' + '20' FROM DUAL;
SELECT TO_NUMBER('10') + TO_NUMBER('20') FROM DUAL;

--DECODE
--일반함수(DECODE : 첫번째 인자로 받은 값을 조건에 맞춰 변경)
--DECODE(표현식, 조건1, 결과1,
--              조건2, 결과2,
--              조건3, 결과3,
--              기본결과

SELECT DEPTNO, DECODE(DEPTNO, 10, 'ACCOUTTING'
                            , 20, 'RESARCH'
                            , 30, 'SALES'
                            , 40, 'OPERATIONS' ) AS DNAME
FROM EMP;

SELECT TO_CHAR(HIREDATE, 'MM') FROM EMP;
SELECT DECODE(TO_CHAR(HIREDATE, 'MM'), '02', 1) FROM EMP;
SELECT COUNT(DECODE(TO_CHAR(HIREDATE, 'MM'), '02', 1)) FROM EMP;
SELECT SUM(DECODE(TO_CHAR(HIREDATE, 'MM'), '02', 1)) FROM EMP;

SELECT COUNT(DECODE(TO_CHAR(HIREDATE, 'MM'), '01', 1)) "1월"
      ,COUNT(DECODE(TO_CHAR(HIREDATE, 'MM'), '02', 1)) "2월"
      ,COUNT(DECODE(TO_CHAR(HIREDATE, 'MM'), '03', 1)) "3월"
      ,COUNT(DECODE(TO_CHAR(HIREDATE, 'MM'), '04', 1)) "4월"
      ,COUNT(DECODE(TO_CHAR(HIREDATE, 'MM'), '05', 1)) "5월"
      ,COUNT(DECODE(TO_CHAR(HIREDATE, 'MM'), '06', 1)) "6월"
      ,COUNT(DECODE(TO_CHAR(HIREDATE, 'MM'), '07', 1)) "7월"
      ,COUNT(DECODE(TO_CHAR(HIREDATE, 'MM'), '08', 1)) "8월"
      ,COUNT(DECODE(TO_CHAR(HIREDATE, 'MM'), '09', 1)) "9월"
      ,COUNT(DECODE(TO_CHAR(HIREDATE, 'MM'), '10', 1)) "10월"
      ,COUNT(DECODE(TO_CHAR(HIREDATE, 'MM'), '11', 1)) "11월"
      ,COUNT(DECODE(TO_CHAR(HIREDATE, 'MM'), '12', 1)) "12월"
FROM EMP
WHERE TO_CHAR(HIREDATE, 'MM') >='01'
AND   TO_CHAR(HIREDATE, 'MM')  <='12';

SELECT SUM(DECODE(TO_CHAR(HIREDATE, 'MM'), '01', 1)) "1월"
      ,SUM(DECODE(TO_CHAR(HIREDATE, 'MM'), '02', 1)) "2월"
      ,SUM(DECODE(TO_CHAR(HIREDATE, 'MM'), '03', 1)) "3월"
      ,SUM(DECODE(TO_CHAR(HIREDATE, 'MM'), '04', 1)) "4월"
      ,SUM(DECODE(TO_CHAR(HIREDATE, 'MM'), '05', 1)) "5월"
      ,SUM(DECODE(TO_CHAR(HIREDATE, 'MM'), '06', 1)) "6월"
      ,SUM(DECODE(TO_CHAR(HIREDATE, 'MM'), '07', 1)) "7월"
      ,SUM(DECODE(TO_CHAR(HIREDATE, 'MM'), '08', 1)) "8월"
      ,SUM(DECODE(TO_CHAR(HIREDATE, 'MM'), '09', 1)) "9월"
      ,SUM(DECODE(TO_CHAR(HIREDATE, 'MM'), '10', 1)) "10월"
      ,SUM(DECODE(TO_CHAR(HIREDATE, 'MM'), '11', 1)) "11월"
      ,SUM(DECODE(TO_CHAR(HIREDATE, 'MM'), '12', 1)) "12월"
FROM EMP
WHERE TO_CHAR(HIREDATE, 'MM') >='01'
AND   TO_CHAR(HIREDATE, 'MM')  <='12';

SELECT DEPTNO, DECODE(DEPTNO, 10, SUM(SAL),
                              20, MAX(SAL),
                              30, MIN(SAL)) SAL
FROM EMP
GROUP BY DEPTNO ORDER BY DEPTNO;

SELECT DEPTNO, NVL(SUM(DECODE(DEPTNO, 10, SAL)), 0) DEPTNO10
              ,NVL(SUM(DECODE(DEPTNO, 20, SAL)), 0) DEPTNO20
              ,NVL(SUM(DECODE(DEPTNO, 30, SAL)), 0) DEPTNO30
              ,NVL(SUM(DECODE(DEPTNO, 40, SAL)), 0) DEPTNO40
FROM EMP
GROUP BY DEPTNO;

SELECT MAX(NVL(SUM(DECODE(DEPTNO, 10, SAL)), 0)) DEPTNO10
      ,MAX(NVL(SUM(DECODE(DEPTNO, 20, SAL)), 0)) DEPTNO20
      ,MAX(NVL(SUM(DECODE(DEPTNO, 30, SAL)), 0)) DEPTNO30
      ,MAX(NVL(SUM(DECODE(DEPTNO, 40, SAL)), 0)) DEPTNO40
FROM EMP
GROUP BY DEPTNO;

--CASE WHEN
--일반함수(CASE : 조건에 맞는 문장을 수행)
--CASE WHEN[조건1] THEN [결과1]
--                ELSE[결과2]
--                END AS[컬럼]
                
SELECT ENAME, SAL
        , CASE
            WHEN SAL < 1000 THEN SAL+ (SAL * 0.8)
            WHEN SAL BETWEEN 1000 AND 2000 THEN SAL + (SAL * 0.5)
            WHEN SAL BETWEEN 2001 AND 3000 THEN SAL + (SAL * 0.3)
            ELSE SAL + (SAL * 0.1)
            END SALUP
FROM EMP;

SELECT COUNT(HIREDATE) FROM EMP;
SELECT HIREDATE FROM EMP;
SELECT COUNT(HIREDATE) FROM EMP
GROUP BY HIREDATE
HAVING TO_CHAR(HIREDATE, 'MM') >= '01'
AND    TO_CHAR(HIREDATE, 'MM') <= '12';


--######################################################
--테이블 컬럼 변경
SELECT * FROM TAB;
CREATE TABLE EMP07
AS
SELECT EMPNO, ENAME, DEPTNO FROM EMP WHERE 1=0;

SELECT * FROM EMP07;
DESC EMP07;

--컬럼 추가 : 
--그 테이블에 컬럼순서에서 맨 뒤에 붙음
-- 단 중간에 끼워 넣을 수 없음
--끼워 넣으려면 테이블 갈아 엎어야함
ALTER TABLE EMP07 ADD (JOB VARCHAR2(9));
ALTER TABLE EMP07 ADD(MGR NUMBER(4));

--컬럼 변경 : 데이터 타입, 사이즈
--1. 해당 컬럼에 데이터가 없는 경우
-- 컬럼의 데이터 타입 변경 가능
-- 컬럼의 크기도 변경 가능
ALTER TABLE EMP07 MODIFY (JOB VARCHAR2(30));
ALTER TABLE EMP07 MODIFY (MGR VARCHAR2(30));

--2. 해당 컬럼에 데이터가 있는 경우
--컬럼의 데이터 타입 변경 불가능
-- 컬럼의 크기는 현재보다 크게만 변경 가능
CREATE TABLE EMP08
AS
SELECT EMPNO, ENAME, MGR, JOB, DEPTNO FROM EMP WHERE 1=1;

SELECT * FROM EMP08;
DROP TABLE EMP08;
DESC EMP08;
DESC EMP;

ALTER TABLE EMP08 MODIFY(JOB VARCHAR2(30));
ALTER TABLE EMP08 MODIFY(MGR VARCHAR2(4)); -- 데이터가 안비어있으면 데이터타입 변경 불가능
--오류 보고 -
--ORA-01439: 데이터 유형을 변경할 열은 비어 있어야 합니다
--01439. 00000 -  "column to be modified must be empty to change datatype"
--*Cause:    
--*Action:
ALTER TABLE EMP08 MODIFY(ENAME VARCHAR2(8));
ALTER TABLE EMP08 MODIFY(ENAME VARCHAR2(6));
ALTER TABLE EMP08 MODIFY(ENAME VARCHAR2(5)); --안에 있는 데이터값이 크기보다 줄일수 없음

--컬럼 삭제
ALTER TABLE EMP07 DROP COLUMN MGR;

SELECT * fROM EMP07;

RENAME EMP08 TO EMP08_1;

SELECT * FROM EMP08;
SELECT * FROM EMP08_1;

CREATE TABLE EMP09
AS 
SELECT EMPNO, ENAME FROM EMP WHERE 1=1;
SELECT * FROM EMP09;

--테이블 구조 삭제
--테이블 삭제 시 무결성 제약조건 체크
--삭제대상 테이블이 다른 테이블과 KEY가 연결되어 있을 경우
--연결된 조건을 확인하고 순서대로 삭제해야 된다.
DROP TABLE EMP09;

CREATE TABLE EMP09_1
AS SELECT EMPNO, ENAME FROM EMP WHERE 1=1;
SELECT * FROM EMP09_1;

--테이블의 모든 데이터 (로우)가 제거한다.
TRUNCATE TABLE EMP09_1;

