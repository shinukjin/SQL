 --그룹 함수
-- 그룹함수의 결과는 1개의 행으로 구해진다.
 --단일함수의 결과는 여러개의 행으로 구해진다.
 
 show user;
 --SUM(), COUNT(),AVG(), MAX(), MIN() 그룹함수 : 결과값이 1개의 행으로 나옴
SELECT SUM(SAL) FROM EMP;
SELECT COUNT (SAL) FROM EMP; -- COUNT() 그룹함수 : 결과값이 1개의 행으로
SELECT AVG(SAL) FROM EMP;
SELECT ROUND(AVG(SAL)) FROM EMP;
SELECT MAX(SAL) FROM EMP;
SELECT MIN(SAL) FROM EMP;

--ROUND(), TO_CHAR() 단일함수 : 결과값이 여러개의 행으로
SELECT ROUND(SAL) FROM EMP; -- ROUND() 단일함수 : 결과값이 여러개의 행으로
SELECT ROUND (2222.1234) FROM DUAL; -- ROUND() : 반올림해줌.
SELECT ROUND (2222.6235, 3) FROM DUAL; -- ROUND() : 소수점 N번째에서 반올림해줌.
SELECT TO_CHAR(HIREDATE, 'YYYY-MM-DD') HIREDATE FROM EMP; 


-- EMP 테이블에서 입사일이 제일 늦은 사원의 사원명, 입사일을 조회
-- ADAMS	87/05/23
SELECT ENAME, HIREDATE FROM EMP ORDER BY HIREDATE DESC; -- 아이체킹

SELECT MAX(HIREDATE) FROM EMP; --입사일이 가장 늦음 : MAX()함수
SELECT MIN(HIREDATE)FROM EMP; --입사일이 가장 빠름 : MIN()함수

SELECT A.ENAME, A.HIREDATE FROM EMP A 
WHERE A.HIREDATE = (SELECT MAX(HIREDATE) FROM EMP); 

--EMP 테이블에서 사번이 제일 빠른 사원의 사원번호, 사원명 입사일을 조회하시오.

SELECT MAX(EMPNO), MIN(EMPNO) FROM EMP;
SELECT ENAME, EMPNO FROM EMP ORDER BY EMPNO; -- 아이체킹 SMITH	7369
SELECT EMPNO, ENAME, HIREDATE FROM EMP
WHERE EMPNO = (SELECT MIN(EMPNO) FROM EMP);

--EMP 테이블에서 급여가 제일많은 사원의 사원번호, 사원명 입사일을 조회하시오.
SELECT MAX(SAL), MIN(SAL) FROM EMP;
SELECT ENAME, SAL FROM EMP ORDER BY SAL DESC; -- 아이체킹 KING 5000
SELECT EMPNO, ENAME, HIREDATE FROM EMP
WHERE SAL = (SELECT MAX(SAL) FROM EMP);
    
    
--EMP 테이블에서 상여가 제일 많은 사원번호, 사원명 입사일을 조회하시오.
SELECT MAX(COMM), MIN(COMM) FROM EMP;
SELECT ENAME, COMM FROM EMP ORDER BY COMM DESC; -- 아이체킹 MARTIN 1400
SELECT EMPNO, ENAME, HIREDATE FROM EMP
WHERE COMM = (SELECT MAX(COMM) FROM EMP);

SELECT EMPNO, ENAME, HIREDATE
FROM EMP
WHERE COMM = (SELECT MAX(COMM) FROM EMP);

--GROUP BY 
SELECT DEPTNO FROM EMP;
SELECT COUNT(DEPTNO) FROM EMP;
SELECT DISTINCT DEPTNO FROM EMP;

SELECT DEPTNO FROM EMP GROUP BY DEPTNO; -- 조회됨
SELECT * FROM EMP GROUP BY DEPTNO; -- GROUP BY 표현식이 아님 , 아스타리스크는 GROUP BY 7에 사용 X
SELECT A.* FROM EMP A GROUP BY A.DEPTNO; -- GROUP BY표현식이 아님
SELECT A.DEPTNO, A.ENAME FROM EMP A GROUP BY A.DEPTNO, A.ENAME; 
SELECT A.DEPTNO, A.JOB FROM EMP A GROUP BY A.DEPTNO, A.JOB;
SELECT DEPTNO, JOB FROM EMP; -- 14건

SELECT A.DEPTNO FROM EMP A GROUP BY A.DEPTNO HAVING A.DEPTNO = 30;
--30부서의 급여 총액

SELECT A.DEPTNO, SUM(A.SAL) FROM EMP A GROUP BY A.DEPTNO HAVING A. DEPTNO =30; -- GROUP BY 사용해서 출력, WHERE 절을 쓰면 안됨 > GROUP BY로
SELECT SUM(A.SAL) FROM EMP A WHERE A.DEPTNO = 30; --30 함수는 행을 하나만 출력하기 때문에 형식에 맞음
SELECT A.EMPNO, SUM(A.SAL) FROM EMP A WHERE A.EMPNO =7369;--A.DEPTNO는 단일함수로 행을 여러개 출력X
SELECT A.EMPNO, SUM(A.SAL) FROM EMP A GROUP BY A.EMPNO;
--A.EMPNO는 단일함수
--SUM(A.SAL)은 그룹함수 
--출력되는 ROW의 갯수가 다름..  
--ORA-00937: 단일 그룹의 그룹 함수가 아닙니다
--00937. 00000 -  "not a single-group group function"
SELECT DEPTNO, SUM(SAL)
FROM EMP
GROUP BY DEPTNO HAVING DEPTNO = 30;
SELECT  A.DEPTNO
        ,COUNT(A.SAL)
        ,SUM(A.SAL)
        ,ROUND(AVG(A.SAL),2)
        ,MAX(A.SAL)
        ,MIN(A.SAL)
FROM    EMP A
GROUP BY A.DEPTNO
HAVING A.DEPTNO = 30;

SELECT  A.DEPTNO
       ,COUNT(A.SAL)
       ,SUM(A.SAL)
       ,ROUND(AVG(A.SAL),2)
       ,MAX(A.SAL)
       ,MIN(A.SAL)
FROM    EMP A
GROUP BY A.DEPTNO
ORDER BY 1;

--ROLLUP 함수
--GROUP BY 절과 함꼐 사용
--SELECT 된 데이터와 그 데이터이 총계를 구함.

SELECT JOB, SAL FROM EMP;
SELECT JOB FROM EMP GROUP BY JOB;
SELECT JOB, SUM(SAL) FROM EMP GROUP BY JOB;
SELECT JOB, SUM(SAL) FROM EMP GROUP BY ROLLUP(JOB);

SELECT DEPTNO, SAL FROM EMP;
SELECT DEPTNO FROM EMP GROUP BY DEPTNO;
SELECT DEPTNO, SUM(SAL) FROM EMP GROUP BY DEPTNO;
SELECT DEPTNO, SUM(SAL) FROM EMP GROUP BY ROLLUP(DEPTNO);

SELECT * FROM (SELECT JOB, SUM(SAL) AS SALSUM FROM EMP GROUP BY JOB);

--부서별 인원 수와 급여 합계

SELECT JOB, SAL FROM EMP;
SELECT JOB FROM EMP GROUP BY JOB;
SELECT JOB, SUM(SAL) FROM EMP GROUP BY JOB;
SELECT JOB, SUM(SAL) FROM EMP GROUP BY ROLLUP(JOB);

SELECT DEPTNO, SAL FROM EMP;
SELECT DEPTNO FROM EMP GROUP BY DEPTNO;
SELECT DEPTNO, SUM(SAL) FROM EMP GROUP BY DEPTNO;
SELECT DEPTNO, SUM(SAL) FROM EMP GROUP BY ROLLUP(DEPTNO);



SELECT B.DNAME, A.JOB, SUM(A.SAL) SAL, COUNT(A.EMPNO) EMPCNT
FROM EMP A, DEPT B
WHERE A.DEPTNO = B.DEPTNO
GROUP BY ROLLUP(B.DNAME, A.JOB)
ORDER BY 1;

-- RANK() OVER()
-- 오라클에서 순위를 부여하는 함수
-- 출력값이 같으면 같은 순위로 부여됨.

--급여 순위를 구해보세요
SELECT   EMPNO, ENAME, SAL FROM EMP ORDER BY 3 DESC;

--RK의 출력값이 급여가 같으면 같은 순위로 부여된다.
SELECT  EMPNO, ENAME, SAL,
        RANK() OVER(ORDER BY SAL DESC) AS RK
FROM EMP;

--중복 RANK 의 수와 무관하게 넘버링
SELECT  EMPNO, ENAME, SAL,
        DENSE_RANK() OVER(ORDER BY SAL DESC) AS RK
FROM EMP;

--그룹별로 순위 부여
SELECT  DEPTNO, EMPNO, ENAME, SAL,
        RANK() OVER(PARTITION BY DEPTNO ORDER BY SAL DESC) AS RK
FROM EMP;

-- ROW NUMBER(0 OVER()
SELECT  ROWNUM, EMPNO, ENAME, SAL,
        ROW_NUMBER() OVER(ORDER BY SAL DESC) 
FROM EMP;

--RANK : 중복 순위 다음 순서 건너뜀.(1,2,2,4)
--DENSE_RANK : 중복순위 다음 순위 연속.(1,2,2,3)
--ROW_NUMBER : 중복순위 없이 유일값.(1,2,3,4)
SELECT DEPTNO, EMPNO, ENAME, SAL 
      ,RANK() OVER(ORDER BY SAL DESC) AS RK 
      ,DENSE_RANK() OVER(ORDER BY SAL DESC) AS DR 
      ,ROW_NUMBER() OVER(ORDER BY SAL DESC) AS RN
FROM EMP; 

--순위 함수 - NTILE(분류)
-- 쿼리결과를 N개 그룹으로 분류하는 기능 
SELECT EMPNO
      ,NTILE(2) OVER(ORDER BY EMPNO) AS GRP_2 
      ,NTILE(3) OVER(ORDER BY EMPNO) AS GRP_3 
      ,NTILE(5) OVER(ORDER BY EMPNO) AS GRP_5 
FROM EMP; 

--CUBE() 함수
SELECT B.DNAME, A.JOB, SUM(A.SAL) SAL, COUNT(A.EMPNO) EMPCNT
FROM EMP A, DEPT B
WHERE A.DEPTNO = B.DEPTNO
GROUP BY CUBE(B.DNAME, A.JOB)
ORDER BY 1;

--오라클 오브젝트
--VIEW
--직접적인 테이블 접근을 제한하기 위해서 사용한다.
--뷰는 테이블에 대한 제한을 가지고 
--테이블의 일정한 부분만 보일 수 있는 가상 테이블이다.

--CREATE AS 구문
--CREATE [OR REPLACE][FORCE | NOFORCE] VIEW viewname
--[(alias, alias ..... )]
--AS subquery

CREATE TABLE EMP02
AS 
SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP;

SHOW USER;
--CONN SYSTEM/1234
--GRANT CREATE VIEW TO SCOTT;


-- 뷰는 가공하는 것이 아님!! 조회만 한다!! (단순 VIEW든 복합VIEW든 ONLY 조회용)

-- 단순 뷰(Simple View) :  기본 테이블이 1개 일 때
-- ISUD가 가능 >> 하지만 하지 않는다. 오직 조회만!!
CREATE VIEW VIEW_EMP02
AS
SELECT * FROM EMP02
WHERE DEPTNO =10;

SELECT * FROM VIEW_EMP02;

INSERT INTO VIEW_EMP02
VALUES (8000, 'ANGEL', 7000, 10);
COMMIT;

-- 복합 뷰(Complex View): 기본테이블이 2개 이상 일 때
-- ISUD  불가능
CREATE VIEW VIEW_EMP_DEPT
AS
SELECT  A.EMPNO, A.ENAME, A.SAL, B.DEPTNO, B.DNAME
FROM    EMP A, DEPT B
WHERE   A.DEPTNO = B.DEPTNO
AND     A.DEPTNO = 10;

SELECT * FROM VIEW_EMP_DEPT;
INSERT INTO VIEW_EMP_DEPT VALUES(1234, AAA, 1111,10, AAA);
-- 복합 VIEW에는 ISUD 불가능

INSERT INTO VIEW_EMP_DEPT  --복합뷰로 가공안됨
VALUES (8001, 'AAAA', 4000, 10, 'ACCUNT');

--뷰 생성시 컬럼명을 조정할 수 있따.
CREATE OR REPLACE VIEW VIEW_EMP02_COL(사원번호, 사원명, 급여, 부서번호) --바꿀 컬럼명
AS
SELECT EMPNO, ENAME, SAL, DEPTNO --기존 컬럼명
FROM EMP02;

SELECT * FROM VIEW_EMP02_COL;

SELECT * FROM VIEW_EMP02_COL WHERE 부서번호 = 10;--바꾼 컬럼명으로 조회됨.
SELECT * FROM VIEW_EMP02_COL WHERE DEPTNO = 10; --컬럼명 변경시 기존 컬럼명으로는 조회가 안됨.

-- 뷰를 새로 만든 것
CREATE OR REPLACE VIEW VIEW_EMP02_COL_1 --뷰 테이블을 새로 만들 때 컬럼명에 엘리어스를 사용하여 변경
AS
SELECT EMPNO AS E_1, ENAME AS E_2, SAL AS E_3, DEPTNO AS E_4
FROM EMP02;
SELECT * FROM EMP02;

INSERT INTO VIEW_EMP02_COL_1(E_1, E_2, E_3, E_4)
VALUES (8000, 'SWJ', 9000, 10);
    
-- 뷰를 변경하는 것
CREATE OR REPLACE VIEW VIEW_EMP02_COL --기존에 있는 뷰 테이플의 컬럼명을 교체함.
AS
SELECT EMPNO T_1, ENAME T_2, SAL T_3, DEPTNO T_4
FROM EMP02;
SELECT * FROM VIEW_EMP02_COL;

--NOFORCE : DEFAULT : 기본테이블이 없으면 뷰를 생성하지 않음
CREATE OR REPLACE VIEW VIEW_EMP02_1
AS
SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP02_NOTABLE
WHERE ROWNUM <=3;

--FORCE : 기본테이블이 없어도 USER_VIEWS 데이터 사전에 뷰를 생성한다.
CREATE OR REPLACE FORCE VIEW VIEW_EMP02_2
AS
SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP02_NOTABLE
WHERE ROWNUM <=3;
--00942. 00000 -  "table or view does not exist"
--*Cause:    
--*Action:
--경고: 컴파일 오류와 함께 뷰가 생성되었습니다.


--WITH CHECK OPTION
--대부분의 뷰는 리드온리로 생성할 것.
CREATE OR REPLACE VIEW VIEW_EMP03
AS
SELECT EMPNO, ENAME, DEPTNO, JOB
FROM EMP
WHERE JOB LIKE 'MANAGER' WITH CHECK OPTION;

INSERT INTO VIEW_EMP03
VALUES (9000, 'ABC', 30, 'SALESMAN');
--ORA-01402: 뷰의 WITH CHECK OPTION의 조건에 위배 됩니다

INSERT INTO VIEW_EMP03
VALUES (9000, 'ABC', 30, 'MANAGER');
SELECT * FROM VIEW_EMP03;
ROLLBACK;

--WITH READ ONLY ; 읽기만 가능
--대부분의 뷰는 리드온리로 생성할 것.
CREATE OR REPLACE VIEW VIEW_EMP04
AS
SELECT EMPNO, ENAME, DEPTNO, JOB
FROM    EMP
WHERE JOB LIKE 'MANAGER' WITH READ ONLY;

INSERT INTO VIEW_EMP04
VALUES(9000, 'ABC', 30, 'MANAGER');
--오류 보고 -
--SQL 오류: ORA-42399: 읽기 전용 뷰에서는 DML 작업을 수행할 수 없습니다.
--42399.0000 - "cannot perform a DML operation on a read-only view"


--SEQUENCE
--SEQUENCE 함수의 경우 다루기 어렵기 떄문에 MAX 채번 로직을 사용한다.
--SEQUENCE 오라클 시퀀스는 자동 증가하는 기능
--MYSQL, 마리아디비 : AUTO_INCREMENT : 자동 증가
CREATE SEQUENCE EMP05_SEQ
       START WITH 1
       INCREMENT BY 1
       MAXVALUE 1000000;
       
CREATE SEQUENCE EMP05_SEQ_1
       START WITH 1
       INCREMENT BY 1
       MAXVALUE 1000000;

CREATE SEQUENCE EMP05_SEQ_2
       START WITH 1
       INCREMENT BY 3
       MAXVALUE 1000000;       

SELECT * FROM USER_SEQUENCES;

CREATE TABLE EMP05
AS
SELECT EMPNO, ENAME, HIREDATE
FROM EMP
WHERE 1=0;  -- 컬럼만 가지고오고 데이터는 x

SELECT * FROM EMP05;

INSERT INTO EMP05 VALUES (EMP05_SEQ.NEXTVAL, 'AAA', SYSDATE);
INSERT INTO EMP05 VALUES (EMP05_SEQ_2.NEXTVAL, 'AAA01', SYSDATE);
INSERT INTO EMP05 VALUES (EMP05_SEQ.NEXTVAL, 'AAA02', SYSDATE);

SELECT EMP05_SEQ_2.NEXTVAL FROM DUAL;
SELECT EMP05_SEQ_2.CURRVAL FROM DUAL;

SELECT EMP05_SEQ.NEXTVAL FROM DUAL;
SELECT EMP05_SEQ.CURRVAL FROM DUAL;
--맥스(MAX())값 채번 로직
SELECT MAX(NVL(NULL, 0)) + 1 FROM DUAL;

--INDEX : 색인 : 영어사전 : 색인 A, B, C, ... , 한글 사전 : 색인 ㄱ, ㄴ, ㄷ, ...
--오라클 데이버에이스에서 INDEX 성능 향상(조회 속도 향상)에서 양날의 검
SELECT  TABLE_NAME, INDEX_NAME, COLUMN_NAME
FROM    USER_IND_COLUMNS
WHERE   TABLE_NAME IN ('EMP', 'DEPT', 'INDEX_TEST_1', 'T2');

--테이블에 생성시 프라이머리 키를 생성하면
--오라클 엔진에서 자동으로 인덱스를 생성한다
--생성하는 이름은 SYS_ 접두어 + C + 0000000 규칙으로 생성한다
--SYS_C0011421 : SYS_ 접두어 + C + 0000000

CREATE TABLE INDEX_TEST_1(
    INDEX_1 NUMBER PRIMARY KEY
);

-- PK 생성 시 자동으로 시스템에서 시스템을 인덱스를 생성하ㅣ 떄문에 
-- 사용자 정의로 인덱스를 생성할 수 없다.

CREATE INDEX INEX_TEST_1_111 ON INDEX_TEST_1(INDEX_1);

--인덱스 생성하기
CREATE TABLE T2(
    T2_1 NUMBER,
    T2_2 VARCHAR2(10)
);

--단일 인덱스
CREATE INDEX INDEX_T2_T2_1 ON T2(T2_1);
--결합 인덱스
CREATE INDEX INDEX_T2_T2_1_T2_2 ON T2(T2_1, T2_2);

--MAXㄱ 값 채번로직 완성하기
CREATE TABLE T3(
    T3_NUM VARCHAR2(20) PRIMARY KEY
    ,DELETEYN VARCHAR2(1)
    ,INSERTDATE DATE
    ,UPDATEDATE DATE
);

--SYS_C0011422
SELECT  TABLE_NAME, INDEX_NAME, COLUMN_NAME
FROM    USER_IND_COLUMNS
WHERE   TABLE_NAME IN('T3');

select * from USER_IND_COLUMNS;
SELECT /*+ INDEX_DESC(SYS_C0011422) */
        NVL(MAX(SUBSTR(A.T3_NUM, -4)), 0) +1 COMMNO
FROM    T3 A;


--오라클 Constraint